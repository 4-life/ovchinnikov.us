var model = {
	content:[     
     //{user:"user", loaction:"loaction", id:"startx", rfid:"rfid1", gridImage:["img/img.png"], copy:"wefgbt54",  story:"some text right there", type:"big_ham", color:"#cbffab", textColor1:"#FFFFFF", textColor2:"#45384A", scale:0.7},	 
     {id:"angular", rfid:"angular", gridImage:["img/angular.png"], copy:"AngularJS",  story:"Superheroic JavaScript MVW Framework", type:"big_ham", color:"#dadada", textColor1:"#c4473a", textColor2:"#c4473a", scale:0.7, langs:"js, html", url: "angularjs.org/"},
     {id:"ionic", rfid:"ionic", gridImage:["img/ionic.png"], copy:"Ionic",  story:"The beautiful, open source front-end SDK for developing hybrid mobile apps with HTML5", type:"big_ham", color:"#4e8ef7", textColor1:"#fff", textColor2:"#45384A", scale:0.7, langs:"js", url: "ionicframework.com/"},
     {id:"mk", rfid:"mk", gridImage:["img/matreshka.png"], copy:"MatreshkaJS",  story:"Small and powerful client-side JavaScript framework that allows you to build single page applications as simply as possible", type:"big_ham", color:"#8bc34a", textColor1:"#fff", textColor2:"#45384A", scale:0.7, langs:"js, html", url: "matreshka.io/"},
     {id:"maskjs", rfid:"maskjs", gridImage:["img/maskjs.png"], copy:"MaskJS",  story:"Markup, template, HMVC engine for modern and fast web, server or mobile applications", type:"big_ham", color:"#e2e2e2", textColor1:"#333", textColor2:"#45384A", scale:0.7, langs:"js, html", url: "github.com/tenbits/MaskJS/"},
     {id:"nodejs", rfid:"nodejs", gridImage:["img/nodejs.png"], copy:"NodeJS",  story:"Platform built on Chrome's JavaScript runtime for easily building fast, scalable network applications. Node.js uses an event-driven, non-blocking I/O model that makes it lightweight and efficient, perfect for data-intensive real-time applications that run across distributed devices", type:"big_ham", color:"#303030", textColor1:"#fff", textColor2:"#80bd01", scale:0.7, langs:"js", url: "nodejs.org/"},
     {id:"react", rfid:"react", gridImage:["img/react.png"], copy:"React",  story:"A javascript library for building user interfaces", type:"big_ham", color:"#222", textColor1:"#00d8ff", textColor2:"#00d8ff", scale:0.7, langs:"js", url: "facebook.github.io/react/"},
     {id:"meteor", rfid:"meteor", gridImage:["img/meteor.png"], copy:"MeteorJS",  story:"Complete open source platform for building web and mobile apps in pure JavaScript", type:"big_ham", color:"#c1c1c1", textColor1:"#de4f4f", textColor2:"#de4f4f", scale:0.7, langs:"js", url: "meteor.com/"},
     {id:"bootstrap", rfid:"bootstrap", gridImage:["img/bootstrap.png"], copy:"Bootstrap",  story:"HTML, CSS, and JS framework for developing responsive, mobile first projects on the web", type:"big_ham", color:"#5c4383", textColor1:"#fff", textColor2:"#fff", scale:0.7, langs:"HTML, CSS, JS", url: "http://getbootstrap.com/"},
     {id:"ember", rfid:"ember", gridImage:["img/ember.png"], copy:"ember",  story:"All Ember methods and functions are defined inside of this namespace. You generally should not add new properties to this namespace as it may be overwritten by future versions of Ember. You can also use the shorthand Em instead of Ember. Ember-Runtime is a framework that provides core functions for Ember including cross-platform functions, support for property observing and objects. Its focus is on small size and performance. You can use this in place of or along-side other cross-platform libraries such as jQuery.", type:"big_ham", color:"#ff6e56", textColor1:"#fff", textColor2:"#fff", scale:0.7, langs:"JS", url: "http://emberjs.com/"},
     {id:"backbone", rfid:"Backbone", gridImage:["img/backbone.png"], copy:"Backbone",  story:"Backbone.js gives structure to web applications by providing models with key-value binding and custom events, collections with a rich API of enumerable functions, views with declarative event handling, and connects it all to your existing API over a RESTful JSON interface.", type:"big_ham", color:"#f7f7f7", textColor1:"#333", textColor2:"#333", scale:0.7, langs:"JS", url: "http://backbonejs.org/"},
     {id:"Cordova", rfid:"Cordova", gridImage:["img/cordova.png"], copy:"Cordova",  story:"Platform for building native mobile applications using HTML, CSS and JavaScript", type:"big_ham", color:"#e6e6e6", textColor1:"#3b4854", textColor2:"#3b4854", scale:0.7, langs:"HTML, CSS, JS", url: "http://cordova.apache.org/"}
	],
	layout:[		
		143,142,141,140,139,138,137,136,135,134,133,132,
		100, 99, 98, 97, 96, 95, 94, 93, 92, 91, 90,131,
		101, 64, 63, 62, 61, 60, 59, 58, 57, 56, 89,130,
		102, 65, 36, 35, 34, 33, 32, 31, 30, 55, 88,129,
		103, 66, 37, 16, 15, 14, 13, 12, 29, 54, 87,128,
		104, 67, 38, 17, 4,  3,  2,  11, 28, 53, 86,127,
		105, 68, 39, 18, 5,  0,  1,  10, 27, 52, 85,126,
		106, 69, 40, 19, 6,  7,  8,  9,  26, 51, 84,125,
		107, 70, 41, 20, 21, 22, 23, 24, 25, 50, 83,124,
		108, 71, 42, 43, 44, 45, 46, 47, 48, 49, 82,123,
		109, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81,122,
		110,111,112,113,114,115,116,117,118,119,120,121
	]
}
var REMOTE_PATH = "./";
window.log = function() {
    log.history = log.history || [];
    log.history.push(arguments);
    if (this.console) {
        arguments.callee = arguments.callee.caller;
        var newarr = [].slice.call(arguments);
        typeof console.log === "object" ? log.apply.call(console.log, console, newarr) : console.log.apply(console, newarr)
    }
};
! function(b) {
    function c() {}
    for (var d = "assert,count,debug,dir,dirxml,error,exception,group,groupCollapsed,groupEnd,info,log,timeStamp,profile,profileEnd,time,timeEnd,trace,warn".split(","), a; a = d.pop();) {
        b[a] = b[a] || c
    }
}(function() {
    try {
        console.log();
        return window.console
    } catch (err) {
        return window.console = {}
    }
}());
if (typeof Function.prototype.bind != "function") {
    Function.prototype.bind = function() {
        var slice = Array.prototype.slice;
        return function(thisArg) {
            var target = this,
                boundArgs = slice.call(arguments, 1);
            if (typeof target != "function") throw new TypeError;

            function bound() {
                var args = boundArgs.concat(slice.call(arguments));
                target.apply(this instanceof bound ? this : thisArg, args)
            }
            bound.prototype = function F(proto) {
                proto && (F.prototype = proto);
                if (!(this instanceof F)) return new F
            }(target.prototype);
            return bound
        }
    }()
}
Date.now = Date.now || function() {
    return +new Date
};
window.requestAnimFrame = function() {
    return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(callback, element) {
        window.setTimeout(callback, 1e3 / 60)
    }
}();

function HEXtoRGB(hex) {
    return [(hex >> 16 & 255) / 255, (hex >> 8 & 255) / 255, (hex & 255) / 255]
}
if (typeof Function.prototype.bind != "function") {
    Function.prototype.bind = function() {
        var slice = Array.prototype.slice;
        return function(thisArg) {
            var target = this,
                boundArgs = slice.call(arguments, 1);
            if (typeof target != "function") throw new TypeError;

            function bound() {
                var args = boundArgs.concat(slice.call(arguments));
                target.apply(this instanceof bound ? this : thisArg, args)
            }
            bound.prototype = function F(proto) {
                proto && (F.prototype = proto);
                if (!(this instanceof F)) return new F
            }(target.prototype);
            return bound
        }
    }()
}
var AjaxRequest = function() {
    var activexmodes = ["Msxml2.XMLHTTP", "Microsoft.XMLHTTP"];
    if (window.ActiveXObject) {
        for (var i = 0; i < activexmodes.length; i++) {
            try {
                return new ActiveXObject(activexmodes[i])
            } catch (e) {}
        }
    } else if (window.XMLHttpRequest) {
        return new XMLHttpRequest
    } else {
        return false
    }
};
if (!Array.prototype.indexOf) {
    Array.prototype.indexOf = function(elt) {
        var len = this.length >>> 0;
        var from = Number(arguments[1]) || 0;
        from = from < 0 ? Math.ceil(from) : Math.floor(from);
        if (from < 0) from += len;
        for (; from < len; from++) {
            if (from in this && this[from] === elt) return from
        }
        return -1
    }
}
Gesturepad = function(target) {
    this.target = target;
    this.startPoint = {
        x: 0,
        y: 0
    };
    this.endPoint = {
        x: 0,
        y: 0
    }
};
Gesturepad.prototype.enable = function() {
    $(document).mousedown($.proxy(this.onMouseDown, this));
    $(document).mouseup($.proxy(this.onMouseUp, this));
    $(document).mousemove($.proxy(this.onMouseMove, this));
    $(document).bind("touchstart", $.proxy(this.onMouseDown, this));
    $(document).bind("touchend", $.proxy(this.onMouseUp, this));
    $(document).bind("touchmove", $.proxy(this.onMouseMove, this))
};
Gesturepad.prototype.disable = function() {
    $(document).unbind("mousedown", $.proxy(this.onMouseDown, this));
    $(document).unbind("mousemove", $.proxy(this.onMouseMove, this));
    $(document).unbind("mouseup", $.proxy(this.onMouseUp, this));
    $(document).unbind("touchstart", $.proxy(this.onMouseDown, this));
    $(document).unbind("touchend", $.proxy(this.onMouseUp, this));
    $(document).unbind("touchmove", $.proxy(this.onMouseMove, this))
};
Gesturepad.prototype.onMouseDown = function(event) {
    if (event) {
        event.preventDefault()
    }
    var rect = this.target.getBoundingClientRect();
    this.dragging = true;
    this.startPoint.x = event.pageX - rect.left;
    this.startPoint.y = event.pageY - rect.top;
    this.endPoint.x = event.pageX - rect.left;
    this.endPoint.y = event.pageY - rect.top
};
Gesturepad.prototype.onMouseUp = function(event) {
    if (event) event.preventDefault();
    this.dragging = false;
    var rect = this.target.getBoundingClientRect();
    var xdist = this.endPoint.x - this.startPoint.x;
    var ydist = this.endPoint.y - this.startPoint.y;
    if (xdist * xdist + ydist * ydist < 30 * 30) {
        var padding = 40;
        var outside = true;
        if (this.endPoint.x > -padding && this.endPoint.x < 500 + padding) {
            if (this.endPoint.y > -padding && this.endPoint.y < 500 + padding) {
                outside = false
            }
        }
        if (outside) {
            if (this.onClose) this.onClose()
        }
        return
    }
    if (Math.abs(xdist) > Math.abs(ydist)) {
        if (xdist < 0) {
            if (this.onSwipe) this.onSwipe("LEFT")
        } else {
            if (this.onSwipe) this.onSwipe("RIGHT")
        }
    } else {
        if (ydist < 0) {
            if (this.onSwipe) this.onSwipe("UP")
        } else {
            if (this.onSwipe) this.onSwipe("DOWN")
        }
    }
    this.startPoint.x = this.endPoint.x;
    this.startPoint.y = this.endPoint.y
};
Gesturepad.prototype.onMouseMove = function(event) {
    var rect = this.target.getBoundingClientRect();
    if (this.dragging) {
        this.endPoint.x = event.pageX - rect.left;
        this.endPoint.y = event.pageY - rect.top
    } else {}
};
var DoubleSpring = function() {
    this.x = 0;
    this.ax = 0;
    this.dx = 0;
    this.tx = 0;
    this.y = 0;
    this.ay = 0;
    this.dy = 0;
    this.ty = 0;
    this.max = 30;
    this.damp = .85;
    this.springiness = .09
};
max = 30;
damp = .85;
springiness = .09;
max = 36;
damp = .72;
springiness = .401;
max = 13;
damp = .63;
springiness = .369;
DoubleSpring.constructor = DoubleSpring;
DoubleSpring.prototype.update = function() {
    this.ax = (this.tx - this.x) * springiness;
    this.dx += this.ax;
    this.dx *= damp;
    if (this.dx < -max) this.dx = -max;
    else if (this.dx > max) this.dx = max;
    this.x += this.dx;
    this.ay = (this.ty - this.y) * springiness;
    this.dy += this.ay;
    this.dy *= damp;
    if (this.dy < -max) this.dy = -max;
    else if (this.dy > max) this.dy = max;
    this.y += this.dy
};
DoubleSpring.prototype.reset = function() {
    this.x = 0;
    this.ax = 0;
    this.dx = 0;
    this.tx = 0;
    this.y = 0;
    this.ay = 0;
    this.dy = 0;
    this.ty = 0
};
Grid = function(width, height) {
    this.padding = 1;
    this.textCanvas = document.createElement("canvas");
    this.textCanvas.width = 250 * 2;
    this.textCanvas.height = 50 * 2;
    this.textCanvas.context = this.textCanvas.getContext("2d");
    this.textCanvas.context.fillStyle = "red";
    this.textCanvas.context.fillRect(0, 0, this.textCanvas.width, this.textCanvas.height);
    this.camera = {
        x: 0,
        y: 0
    };
    this.squareWidth = 250;
    this.nodePool = [];
    this.points = [];
    this.colors = ["#b494bb", "#a2b878", "#af98ad", "#d9d3c5", "#6ca86c", "#aea677", "#4fb4c6", "#80c6e8"];
    this.start = true;
    this.locked = true;
    this.startZoom = 5;
    this.resize(width, height);
    this.zoomRatio = 0;
    this.startFade = 0
};
Grid.constructor = Grid;
Grid.prototype.resize = function(width, height) {
    this.width = width;
    this.height = height;
    this.gridWidth = Math.ceil(this.width / this.squareWidth) + 2 + this.padding + 1;
    this.gridHeight = Math.ceil(this.height / this.squareWidth) + 2 + this.padding + 1;
    var totalPoints = this.gridWidth * this.gridHeight;
    this.odd = this.gridWidth % 2;
    for (var i = 0; i < this.points.length; i++) {
        this.nodePool.push(this.points[i])
    }
    this.points = [];
    for (var i = 0; i < totalPoints; i++) {
        var node = this.nodePool.pop();
        if (!node) {
            node = {
                spring: new DoubleSpring,
                alpha: 1,
                color: this.colors[Math.round(Math.random() * 25) % 2],
                image: new Image,
                ratio: 0
            }
        }
        var xpos = i % this.gridWidth;
        var ypos = Math.floor(i / this.gridWidth);
        node.x = node.xHome = xpos;
        node.y = node.yHome = ypos;
        this.points.push(node)
    }
    this.scale = 1
};
Grid.prototype.startIntro = function() {
    TweenLite.to(this, 2, {
        startZoom: 1,
        ease: Expo.easeInOut,
        onComplete: this.onZoomedOut.bind(this)
    });
    TweenLite.to(this, .1, {
        startFade: 1,
        ease: Expo.easeInOut,
        delay: 2,
        onComplete: this.onTransitionFinished
    })
};
Grid.prototype.onZoomedOut = function() {
    this.start = false;
    this.locked = false;
    SOUNDS.drag.play();
    this.onStartComplete()
};
Grid.prototype.render = function(context) {
    context.save();
    var speedX = (track.x - this.camera.x) * .4;
    var speedY = (track.y - this.camera.y) * .4;
    var speed = Math.sqrt(speedY * speedY + speedX * speedX);
    var fakeX = Math.abs(speed);
    if (fakeX > 40) fakeX = 40;
    fakeX /= 40;
    fakeX *= .25;
    var vol = fakeX * 4;
    if (vol < .1) vol = 0;
    if (vol > 1) vol = 1;
    SOUNDS.drag.volume(vol);
    this.scale += (1 - fakeX - this.scale) * .1;
    if (this.start) {
        this.scale = this.startZoom;
        this.camera.x = track.x;
        this.camera.y = track.y;
        if (this.scale == 5) {}
    } else {
        this.camera.x += speedX;
        this.camera.y += speedY
    }
    var scaleRatio = this.scale + (1 - this.scale) * this.zoomRatio;
    context.translate(this.width / 2, this.height / 2);
    context.scale(scaleRatio, scaleRatio);
    context.translate(-this.squareWidth * (this.padding + 1), -this.squareWidth * 1.5);
    context.translate(Math.floor(-this.width / 2), -Math.floor(this.height / 2));
    var offset = this.squareWidth;
    var totalX = this.squareWidth * this.gridWidth;
    var totalY = this.squareWidth * this.gridHeight;
    for (var i = 0; i < this.points.length; i++) {
        var point = this.points[i];
        point.spring.update();
        var segmentXPosition = point.x * this.squareWidth + this.camera.x;
        var segmentYPosition = point.y * this.squareWidth + this.camera.y;
        var xid = Math.floor(segmentXPosition / totalX);
        xid *= this.gridWidth;
        xid -= point.x;
        var yid = Math.floor(segmentYPosition / totalY);
        yid *= this.gridHeight;
        yid -= point.y;
        if (point.xid != xid || point.yid != yid) {
            var momentId = Grid.getId(xid, yid);
            var moment = model.content[momentId];
            if (moment.id == "share") {
                moment = model.share[moment.visualId || 0];
                moment.id = "share"
            }
            point.moment = moment;
            if (point.moment.scale) {
                point.scale = 1 - point.moment.scale
            } else {
                point.scale = .2
            }
            point.color = point.moment.color;
            point.isStart = false;
            if (xid == -3 && yid == -3) {
                point.isStart = true
            }
            point.image.src = REMOTE_PATH + point.moment.gridImage[0]
        }
        point.xid = xid;
        point.yid = yid;
        segmentXPosition = segmentXPosition % totalX;
        if (segmentXPosition < 0) segmentXPosition += totalX;
        segmentYPosition = segmentYPosition % totalY;
        if (segmentYPosition < 0) segmentYPosition += totalY;
        point.xReal = segmentXPosition;
        point.yReal = segmentYPosition;
        point.xReals = segmentXPosition + point.spring.x * (1 - this.zoomRatio);
        point.yReals = segmentYPosition + point.spring.y * (1 - this.zoomRatio);
        point.spring.tx = point.xHome;
        point.spring.ty = point.yHome;
        context.fillStyle = "black";
        context.globalAlpha = 1
    }
    for (var i = 0; i < this.points.length; i++) {
        var point = this.points[i];
        if (point.xReal < (this.gridWidth - 1) * this.squareWidth && point.yReal < (this.gridHeight - 1) * this.squareWidth) {
            var topLeft = point;
            var topRight = this.points[this.gridWidth * (point.y % this.gridHeight) + (point.x + 1) % this.gridWidth];
            var bottomRight = this.points[this.gridWidth * ((point.y + 1) % this.gridHeight) + (point.x + 1) % this.gridWidth];
            var bottomLeft = this.points[this.gridWidth * ((point.y + 1) % this.gridHeight) + point.x % this.gridWidth]; {
                context.globalAlpha = 1;
                if (point.isStart) context.globalAlpha = this.startFade;
                context.fillStyle = point.color;
                context.beginPath();
                context.moveTo(topLeft.xReals - 1, topLeft.yReals - 1);
                context.lineTo(topRight.xReals + 1, topRight.yReals - 1);
                context.lineTo(bottomRight.xReals + 1, bottomRight.yReals + 1);
                context.lineTo(bottomLeft.xReals - 1, bottomLeft.yReals + 1);
                context.closePath();
                context.fill()
            }
            var centerPointX = (topLeft.xReals + topRight.xReals + bottomRight.xReals + bottomLeft.xReals) / 4;
            var centerPointY = (topLeft.yReals + topRight.yReals + bottomRight.yReals + bottomLeft.yReals) / 4;
            var averageWidth = topRight.xReals - topLeft.xReals;
            var averageWidth2 = bottomRight.xReals - bottomLeft.xReals;
            averageWidth3 = averageWidth < averageWidth2 ? averageWidth : averageWidth2;
            var averageHeight = topLeft.yReals - bottomLeft.yReals;
            var averageHeight2 = topRight.yReals - bottomRight.yReals;
            averageHeight3 = averageHeight > averageHeight2 ? averageHeight : averageHeight2;
            var image = point.image;
            var sizeX = averageWidth3 / this.squareWidth * 250;
            var sizeY = averageHeight3 / this.squareWidth * 250;
            if (sizeX < 0) sizeX *= -1;
            if (sizeY < 0) sizeY *= -1;
            if (i == 0) {}
            var av1 = averageWidth2 / averageWidth;
            var av1_ = averageWidth / averageWidth2;
            av1 = av1 > av1_ ? av1 : av1_;
            var av2 = averageHeight / averageHeight2;
            var av2_ = averageHeight2 / averageHeight;
            av2 = av2 > av2_ ? av2 : av2_;
            context.fillStyle = "#000000";
            if (this.overCell != point) {
                context.globalAlpha = 1;
                if (point.isStart) {
                    context.globalAlpha = this.startFade;
                    if (this.startFade < 1) {
                        sizeX = 250;
                        sizeY = 250
                    }
                    context.drawImage(image, centerPointX - sizeX / 2, centerPointY - sizeY / 2, sizeX, sizeY)
                } else {
                    context.drawImage(image, centerPointX - sizeX / 2, centerPointY - sizeY / 2, sizeX, sizeY)
                }
            } else {
                context.globalAlpha = 1;
                var scaleX = averageWidth3 / this.squareWidth;
                var scaleY = averageHeight3 / this.squareWidth;
                if (scaleX < 0) scaleX *= -1;
                if (scaleY < 0) scaleY *= -1;
                var averageTop = (topLeft.yReals + topRight.yReals) / 2;
                var ratio = point.ratio;
                var scale = 1 - ratio * .2;
                var imagePositionY = centerPointY - sizeY / 2;
                var imagePositionY2 = averageTop;
                var imagePositionYoutput = imagePositionY + (imagePositionY2 - imagePositionY) * ratio;
                if (point.moment.id == "share") {
                    var imageModScale = 1 - ratio * point.scale;
                    var imagePosScale = 1 - ratio * .35;
                    imagePositionYoutput -= ratio * 30;
                    context.drawImage(image, centerPointX - sizeX * imageModScale / 2, imagePositionYoutput, sizeX * imageModScale, sizeY * imageModScale);
                    scaleX *= 1 / 1.37;
                    scaleY *= 1 / 1.37;
                    context.globalAlpha = this.overCell.alpha1;
                    context.drawImage(this.andMaybeText, centerPointX - 282 / 2 * scaleX, averageTop + sizeY * scale + 10 * scaleY, 282 * scaleX, 39 * scaleY);
                    context.globalAlpha = this.overCell.alpha2;
                    context.drawImage(this.tellUsButton.getNextImage(), centerPointX - 226 / 2 * scaleX, averageTop + sizeY * scale - 70 * scaleY, 226 * scaleX, 67 * scaleY)
               // } else if (point.moment.id == "startx") {
                    //context.drawImage(image, centerPointX - sizeX * scale / 2, imagePositionYoutput, sizeX * scale, sizeY * scale);
                    //scaleX *= 1 / 1.37;
                   // scaleY *= 1 / 1.37;
                    //context.globalAlpha = this.overCell.alpha1;
                    //context.drawImage(this.tellMeMoreButton.getNextImage(), centerPointX - 226 / 2 * scaleX, averageTop + sizeY * scale - 35 * scaleY, 226 * scaleX, 67 * scaleY)
                } else {
                    var imageScale = 1 - ratio * point.scale;
                    context.drawImage(image, centerPointX - sizeX * imageScale / 2, imagePositionYoutput, sizeX * imageScale, sizeY * imageScale);
                    context.globalAlpha = this.overCell.alpha1;
                    context.drawImage(this.textCanvas, centerPointX - 250 / 2 * scaleX, averageTop + sizeY * scale - 45 * scaleY, 250 * scaleX, 50 * scaleY);
                    context.globalAlpha = this.overCell.alpha2;
                    //context.drawImage(this.button.getNextImage(), centerPointX - 100 * scaleX, averageTop + sizeY * scale - 0 * scaleY, 200 * scaleX, 40 * scaleY)
                }
            }
            context.fillStyle = "#463e40";
            context.globalAlpha = (av1 + av2) / 2 - 1;
            if (context.globalAlpha > 0) {
                context.beginPath();
                context.moveTo(topLeft.xReals - 1, topLeft.yReals - 1);
                context.lineTo(topRight.xReals + 1, topRight.yReals - 1);
                context.lineTo(bottomRight.xReals + 1, bottomRight.yReals + 1);
                context.lineTo(bottomLeft.xReals - 1, bottomLeft.yReals + 1);
                context.closePath();
                context.fill()
            }
        }
    }
    if (!this.locked) {
        var currentOver = this.hittest();
        if (currentOver) {
            if (currentOver != this.overCell) {
                this.overCell = currentOver;
                this.overCell.count = 0;
                this.overCell.ratio = 0;
                this.overCell.alpha1 = 0;
                this.overCell.alpha2 = 0
            }
            this.overCell.count++;
            if (this.overCell.count == 2) {
                if (!isIpad) SOUNDS.rollOver.play();
                if (this.overCell.moment.id == "share") {
                    TweenLite.to(this.overCell, .2, {
                        ratio: 1,
                        ease: Sine.easeInOut
                    });
                    TweenLite.to(this.overCell, .1, {
                        alpha1: 1,
                        ease: Sine.easeInOut,
                        delay: .1
                    });
                    TweenLite.to(this.overCell, .3, {
                        alpha2: 1,
                        ease: Sine.easeInOut,
                        delay: .2
                    })
                } else {
                    this.textCanvas.context.fillStyle = "green";
                    this.textCanvas.context.clearRect(0, 0, this.textCanvas.width, this.textCanvas.height);
                    this.textCanvas.context.textBaseline = "top";
                    this.textCanvas.context.font = "40pt Calibri, Helvetica, Arial, sans-serif";
                    this.textCanvas.context.fillStyle = this.overCell.moment.textColor1 || "white";
                    var copy = this.overCell.moment.copy;
                    var textWidth = this.textCanvas.context.measureText(copy).width;
                    this.textCanvas.context.fillText(copy, this.textCanvas.width / 2 - textWidth / 2, 0);
                    this.textCanvas.context.fillStyle = this.overCell.moment.textColor2 || "white";
                    this.textCanvas.context.font = "bold 16pt Calibri, Helvetica, Arial, sans-serif";
                    var detailCopy = this.overCell.moment.langs;
                    var detailTextWidth = this.textCanvas.context.measureText(detailCopy).width;
                    this.textCanvas.context.fillText(detailCopy, this.textCanvas.width / 2 - detailTextWidth / 2, 56);
                    this.textCanvas.context.globalAlpha = 1;
                    TweenLite.to(this.overCell, .2, {
                        ratio: 1,
                        ease: Sine.easeInOut
                    });
                    TweenLite.to(this.overCell, .1, {
                        alpha1: 1,
                        ease: Sine.easeInOut,
                        delay: .1
                    });
                    TweenLite.to(this.overCell, .3, {
                        alpha2: 1,
                        ease: Sine.easeInOut,
                        delay: .2
                    })
                }
            }
            this.overCell.alpha = .2;
            var growth = this.overCell.down && !this.didMove ? -30 : 40;
            point = this.overCell;
            this.effectCell(point, growth)
        }
    }
    context.restore()
};
Grid.prototype.effectCell = function(point, growth) {
    var topLeft = point;
    var topRight = this.points[this.gridWidth * (point.y % this.gridHeight) + (point.x + 1) % this.gridWidth];
    var bottomRight = this.points[this.gridWidth * ((point.y + 1) % this.gridHeight) + (point.x + 1) % this.gridWidth];
    var bottomLeft = this.points[this.gridWidth * ((point.y + 1) % this.gridHeight) + point.x % this.gridWidth];
    var rotation = Math.PI / 4;
    topLeft.spring.tx = -growth;
    topLeft.spring.ty = -growth * 1.3;
    topRight.spring.tx = +growth * 1.3;
    topRight.spring.ty = -growth;
    bottomRight.spring.tx = +growth;
    bottomRight.spring.ty = +growth * 1.3;
    bottomLeft.spring.tx = -growth;
    bottomLeft.spring.ty = +growth
};
Grid.prototype.centerOnMoment = function() {
    this.locked = true;
    TweenLite.to(this, .4, {
        zoomRatio: 1,
        ease: Cubic.easeIn
    });
    if (this.overCell) {
        this.overCell.ratio = 0;
        this.overCell.count = 0;
        this.overCell.alpha1 = 0;
        this.overCell.alpha2 = 0
    }
};
Grid.prototype.unlock = function() {
    this.locked = false;
    TweenLite.to(this, .2, {
        zoomRatio: 0
    })
};
Grid.prototype.down = function() {
    this.overCell = this.hittest();
    this.overCell.down = true;
    this.didMove = false;
    this.overCell.count = 0;
    this.overCell.ratio = 0;
    this.overCell.alpha1 = 0;
    this.overCell.alpha2 = 0
};
Grid.prototype.stabilize = function() {
    for (var i = 0; i < this.points.length; i++) {
        var point = this.points[i]
    }
};
Grid.prototype.hittest = function() {
    document.body.style.cursor = "default";
    if (this.overCell) {
        var point = this.overCell;
        var topLeft = point;
        var topRight = this.points[this.gridWidth * (point.y % this.gridHeight) + (point.x + 1) % this.gridWidth];
        var bottomRight = this.points[this.gridWidth * ((point.y + 1) % this.gridHeight) + (point.x + 1) % this.gridWidth];
        var bottomLeft = this.points[this.gridWidth * ((point.y + 1) % this.gridHeight) + point.x % this.gridWidth];
        var distX = topRight.xReal - point.xReal;
        var distY = bottomRight.yReal - point.yReal;
        var positionX = mouse.x - point.xReal + this.squareWidth * 2;
        var positionY = mouse.y - point.yReal + this.squareWidth * 1.5;
        if (positionX > 0 && positionX < distX && positionY > 0 && positionY < distY + 40) {
            if (point.moment.id == "share") {
                if (positionX > 18 && positionX < distX - 22 && positionY > 165 && positionY < distY - 30) {
                    document.body.style.cursor = "pointer"
                }
            } else if (point.moment.id == "startx") {
                if (positionX > 18 && positionX < distX - 22 && positionY > 195 && positionY < distY + 10) {
                    document.body.style.cursor = "pointer"
                }
            } else {
                if (positionX > 5 && positionX < distX - 5 && positionY > 230 && positionY < distY + 24) {
                    document.body.style.cursor = "pointer"
                }
            }
            return this.overCell
        }
    }
    var gridPosX = Math.floor((mouse.x - this.camera.x) / this.squareWidth) + 2;
    var gridPosY = Math.floor((mouse.y - this.camera.y + this.squareWidth * .5) / this.squareWidth) + 1;
    gridPosX %= this.gridWidth;
    if (gridPosX < 0) gridPosX += this.gridWidth;
    gridPosY %= this.gridHeight;
    if (gridPosY < 0) gridPosY += this.gridHeight;
    return this.points[gridPosY % this.gridHeight * this.gridWidth + gridPosX]
};
Grid.prototype.up = function() {
    if (this.overCell.down) {
        this.overCell.down = false;
        if (!this.didMove) {
            var positionX = this.overCell.xid;
            if (positionX < -this.gridWidth) positionX += this.gridWidth;
            var positionY = this.overCell.yid;
            point = this.overCell;
            var topLeft = point;
            var topRight = this.points[this.gridWidth * (point.y % this.gridHeight) + (point.x + 1) % this.gridWidth];
            var bottomRight = this.points[this.gridWidth * ((point.y + 1) % this.gridHeight) + (point.x + 1) % this.gridWidth];
            var bottomLeft = this.points[this.gridWidth * ((point.y + 1) % this.gridHeight) + point.x % this.gridWidth];
            var offsetX = -this.width / 2 - this.squareWidth * (this.padding + 1);
            var offsetY = -this.height / 2 - this.squareWidth * 1.5;
            this.overCell.moment.corners = [{
                x: topLeft.xReals + offsetX,
                y: topLeft.yReals + offsetY
            }, {
                x: topRight.xReals + offsetX,
                y: topRight.yReals + offsetY
            }, {
                x: bottomRight.xReals + offsetX,
                y: bottomRight.yReals + offsetY
            }, {
                x: bottomLeft.xReals + offsetX,
                y: bottomLeft.yReals + offsetY
            }];
            //console.log(positionY);
            this.overCell.moment.positionX = (positionX + 2 - .5) * this.squareWidth + this.width / 2 - this.squareWidth / 2 + 1;
            this.overCell.moment.positionY = (positionY + 1.5 - .5) * this.squareWidth + this.height / 2 - this.squareWidth / 2 + 1;
            this.overCell.moment.positionX = Math.floor(this.overCell.moment.positionX);
            this.overCell.moment.positionY = Math.floor(this.overCell.moment.positionY);
            if (this.overCell.y == 0) this.overCell.moment.positionY -= 2;
            if (this.overCell.x == 0) this.overCell.moment.positionX -= 1;
            this.overCell.moment.color = point.color;
            this.overCell.moment.image = point.image;
            this.onMomentSelected(this.overCell.moment)
        }
    }
};
Grid.getId = function(xid, yid) {
    var gridWidth = model.dimensions[0];
    var gridHeight = model.dimensions[1];
    var modX = (xid - 4) % gridWidth;
    if (modX < 0) modX += gridWidth;
    var modY = (yid - 3) % gridHeight;
    if (modY < 0) modY += gridHeight;
    var id = model.layout[modY * gridWidth + modX];
    if (id >= model.content.length) id++;
    var momentId = id % model.content.length;
    if (yid == 0)
        if (momentId < 0) momentId += model.content.length;
    return momentId
};









Trackpad = function(target) {
    this.target = target;
    this.value = 0;
    this.easingValue = 0;
    this.dragOffset = 0;
    this.dragging;
    this.speed = 0;
    this.prevPosition = 0;
    this.valueY = 0;
    this.easingValueY = 0;
    this.dragOffsetY = 0;
    this.speedY = 0;
    this.prevPositionY = 0;
    $(this.target).mousedown($.proxy(this.onMouseDown, this));
    this.target.onmousewheel = $.proxy(this.onMouseWheel, this);
    this.target.ontouchstart = $.proxy(this.onTouchStart, this);
    $(document).keydown($.proxy(this.onArrow, this))
};
Trackpad.constructor = Trackpad;
Trackpad.prototype.unlock = function() {
    this.locked = false;
    this.speed = 0;
    this.easingValue = this.value;
    this.target.focus()
};
Trackpad.prototype.lock = function() {
    this.locked = true
};
Trackpad.prototype.update = function() {
    this.value = this.easingValue;
    this.valueY = this.easingValueY;
    if (this.dragging) {
        var newSpeed = this.easingValue - this.prevPosition;
        newSpeed *= .7;
        this.speed += (newSpeed - this.speed) * .5;
        this.prevPosition = this.easingValue;
        var newSpeedY = this.easingValueY - this.prevPositionY;
        newSpeedY *= .7;
        this.speedY += (newSpeedY - this.speedY) * .5;
        this.prevPositionY = this.easingValueY
    } else {
        this.speed *= .95;
        this.easingValue += this.speed;
        this.speedY *= .95;
        this.easingValueY += this.speedY
    }
};
Trackpad.prototype.onArrow = function(event) {
    if (event.keyCode == 38) {
        this.speed = 4;
        return false
    } else if (event.keyCode == 40) {
        this.speed -= 4;
        return false
    }
};
Trackpad.prototype.setPosition = function(value, valueY) {
    this.value = this.easingValue = value;
    this.valueY = this.easingValueY = valueY
};
Trackpad.prototype.onMouseWheel = function(event) {
    event.preventDefault ? event.preventDefault() : event.returnValue = false;
    if (this.locked) return;
    this.speed = event.wheelDeltaX * .15;
    this.speedY = event.wheelDeltaY * .15
};
Trackpad.prototype.startDrag = function(newPosition, newPositionY) {
    if (this.locked) return;
    this.dragging = true;
    this.dragOffset = newPosition - this.value;
    this.dragOffsetY = newPositionY - this.valueY
};
Trackpad.prototype.endDrag = function(newPosition) {
    if (this.locked) return;
    this.dragging = false
};
Trackpad.prototype.updateDrag = function(newPositionX, newPositionY) {
    if (this.locked) return;
    this.easingValue = newPositionX - this.dragOffset;
    this.easingValueY = newPositionY - this.dragOffsetY
};
Trackpad.prototype.onMouseDown = function(event) {
    if (event) event.preventDefault();
    event.returnValue = false;
    $(document).mousemove($.proxy(this.onMouseMove, this));
    $(document).mouseup($.proxy(this.onMouseUp, this));
    this.startDrag(event.pageX, event.pageY)
};
Trackpad.prototype.onMouseMove = function(event) {
    if (event) event.preventDefault();
    this.updateDrag(event.pageX, event.pageY)
};
Trackpad.prototype.onMouseUp = function(event) {
    $(document).unbind("mousemove", $.proxy(this.onMouseMove, this));
    $(document).unbind("mouseup", $.proxy(this.onMouseUp, this));
    this.endDrag()
};
Trackpad.prototype.onTouchStart = function(event) {
    this.target.ontouchmove = $.proxy(this.onTouchMove, this);
    this.target.ontouchend = $.proxy(this.onTouchEnd, this);
    this.startDrag(event.touches[0].clientX, event.touches[0].clientY)
};
Trackpad.prototype.onTouchMove = function(event) {
    event.preventDefault();
    this.updateDrag(event.touches[0].clientX, event.touches[0].clientY)
};
Trackpad.prototype.onTouchEnd = function(event) {
    this.target.ontouchmove = null;
    this.target.ontouchend = null;
    this.endDrag()
};
var newSet = 100;
var Viewer = function(width, height) {
    this.width = width;
    this.height = height;
    this.topLeft = {
        x: 0,
        y: 0
    };
    this.topRight = {
        x: 0,
        y: 0
    };
    this.bottomRight = {
        x: 0,
        y: 0
    };
    this.bottomLeft = {
        x: 0,
        y: 0
    };
    this.topLeftFrame = {
        x: 0,
        y: 0
    };
    this.topRightFrame = {
        x: 0,
        y: 0
    };
    this.bottomRightFrame = {
        x: 0,
        y: 0
    };
    this.bottomLeftFrame = {
        x: 0,
        y: 0
    };
    this.alpha = 1;
    this.imageAlpha = 1;
    this.blackStrength = 0;
    this.kickBack = new Image;
    this.kickBack.src = REMOTE_PATH + "img/animationShadow.png";
    this.socialSpring = [{
        x: 0,
        y: 0
    }, {
        x: 0,
        y: 0
    }, {
        x: 0,
        y: 0
    }, {
        x: 0,
        y: 0
    }];
    this.momentSpring = [{
        x: 0,
        y: 0
    }, {
        x: 0,
        y: 0
    }, {
        x: 0,
        y: 0
    }, {
        x: 0,
        y: 0
    }]
};
Viewer.prototype.render = function(context) {
    if (!this.moment) return;
    context.save();
    if (this.blackStrength > 0) {
        context.globalAlpha = this.blackStrength;
        context.fillStyle = "#FFFFFF";
        context.fillRect(0, 0, this.width, this.height)
    }
    context.translate(this.width / 2, this.height / 2);
    context.globalAlpha = this.alpha * (1 - this.imageAlpha);
    context.drawImage(this.kickBack, -518 / 2 - 4, -518 / 2 + 4);
    context.globalAlpha = this.alpha;
    context.fillStyle = "#f0ede9";
    context.fillStyle = this.moment.id == "share" ? "#463849" : this.color;
    context.beginPath();
    context.moveTo(this.topLeft.x, this.topLeft.y);
    context.lineTo(this.topRight.x, this.topRight.y);
    context.lineTo(this.bottomRight.x, this.bottomRight.y);
    context.lineTo(this.bottomLeft.x, this.bottomLeft.y);
    context.closePath();
    context.fill();
    var centerPointX = (this.topLeft.x + this.topRight.x + this.bottomRight.x + this.bottomLeft.x) / 4;
    var centerPointY = (this.topLeft.y + this.topRight.y + this.bottomRight.y + this.bottomLeft.y) / 4;
    var averageWidth = this.topRight.x - this.topLeft.x;
    var averageWidth2 = this.bottomRight.x - this.bottomLeft.x;
    averageWidth3 = averageWidth < averageWidth2 ? averageWidth : averageWidth2;
    var averageHeight = this.topLeft.y - this.bottomLeft.y;
    var averageHeight2 = this.topRight.y - this.bottomRight.y;
    averageHeight3 = averageHeight > averageHeight2 ? averageHeight : averageHeight2;
    var image = this.moment.image;
    if (image) {
        var sizeX = averageWidth3 / 240 * image.width;
        var sizeY = averageHeight3 / 240 * image.height;
        if (sizeX < 0) sizeX *= -1;
        if (sizeY < 0) sizeY *= -1;
        var av1 = averageWidth2 / averageWidth;
        var av1_ = averageWidth / averageWidth2;
        av1 = av1 > av1_ ? av1 : av1_;
        var av2 = averageHeight / averageHeight2;
        var av2_ = averageHeight2 / averageHeight;
        av2 = av2 > av2_ ? av2 : av2_;
        context.globalAlpha = this.imageAlpha * this.alpha;
        context.drawImage(image, centerPointX - sizeX / 2, centerPointY - sizeY / 2, sizeX, sizeY)
    }
    context.restore()
};
Viewer.prototype.resize = function(width, height) {
    this.width = width;
    this.height = height
};

function RGBtoHEX(RGB) {
    return "#" + ((1 << 24) + (RGB[0] << 16) + (RGB[1] << 8) + RGB[2]).toString(16).slice(1)
}

function hexToRgb(hex) {
    var bigint = parseInt(hex.substring(1), 16);
    var r = bigint >> 16 & 255;
    var g = bigint >> 8 & 255;
    var b = bigint & 255;
    return [r, g, b]
}
Viewer.prototype.showMoment = function(moment) {
    this.moment = moment;
    this.color = moment.color;
    this.alpha = 1;
    this.imageAlpha = 1;
    var fbColorSplit = hexToRgb(moment.color);
    fbColorSplit[0] = Math.floor(fbColorSplit[0] * .7);
    fbColorSplit[1] = Math.floor(fbColorSplit[1] * .7);
    fbColorSplit[2] = Math.floor(fbColorSplit[2] * .7);
    this.fbColor = RGBtoHEX(fbColorSplit);
    this.moment.fbColor = this.fbColor;
    if (moment.corners) {
        this.topLeft.x = moment.corners[0].x;
        this.topLeft.y = moment.corners[0].y;
        this.topRight.x = moment.corners[1].x;
        this.topRight.y = moment.corners[1].y;
        this.bottomRight.x = moment.corners[2].x;
        this.bottomRight.y = moment.corners[2].y;
        this.bottomLeft.x = moment.corners[3].x;
        this.bottomLeft.y = moment.corners[3].y
    }
    var speed = .8;
    var delays;
    if (moment.corners) {
        if (moment.corners[0].x < 0) {
            if (moment.corners[0].y < 0) {
                delays = [.4, .3, .2, .1]
            } else {
                delays = [0, .1, .2, .3]
            }
        } else {
            if (moment.corners[0].y < 0) {
                delays = [.2, .3, 0, .1]
            } else {
                delays = [.1, 0, .3, .2]
            }
        }
    } else {
        delays = [0, .1, .2, .3]
    }
    if (this.moment.id != "share" && this.moment.id != "startx") {
        TweenLite.to(this.topLeft, .5 * speed, {
            x: -250,
            y: -250,
            ease: Back.easeOut,
            delay: delays[0]
        });
        TweenLite.to(this.topRight, .5 * speed, {
            x: 250,
            y: -250,
            ease: Back.easeOut,
            delay: delays[1] * speed
        });
        TweenLite.to(this.bottomRight, .5 * speed, {
            x: 250,
            y: 250,
            ease: Back.easeOut,
            delay: delays[2] * speed
        });
        TweenLite.to(this.bottomLeft, .5 * speed, {
            x: -250,
            y: 250,
            ease: Back.easeOut,
            delay: delays[3] * speed,
            onComplete: this.onSquareComplete.bind(this)
        });
        TweenLite.to(this.socialSpring[0], .5 * speed, {
            x: 250,
            y: -250 + 311 - 14 + newSet,
            ease: Elastic.easeOut,
            delay: .4 + 0
        });
        TweenLite.to(this.socialSpring[1], .5 * speed, {
            x: 250 + 75,
            y: -250 + 311 + newSet,
            ease: Elastic.easeOut,
            delay: .4 + .1 * speed
        });
        TweenLite.to(this.socialSpring[2], .5 * speed, {
            x: 250 + 75,
            y: -250 + 311 + 65 + newSet,
            ease: Elastic.easeOut,
            delay: .4 + .2 * speed
        });
        TweenLite.to(this.socialSpring[3], .5 * speed, {
            x: 250,
            y: -250 + 311 + 65 + newSet,
            ease: Elastic.easeOut,
            delay: .4 + .3 * speed
        });
        TweenLite.to(this.momentSpring[0], .5 * speed, {
            x: 250,
            y: -250 + 311 + 65,
            ease: Elastic.easeOut,
            delay: .7 + 0
        });
        TweenLite.to(this.momentSpring[1], .5 * speed, {
            x: 250 + 75,
            y: -250 + 311 + 65,
            ease: Elastic.easeOut,
            delay: .7 + .1 * speed
        });
        TweenLite.to(this.momentSpring[2], .5 * speed, {
            x: 250 + 75,
            y: -250 + 311 + 65 + 75,
            ease: Elastic.easeOut,
            delay: .7 + .2 * speed
        });
        TweenLite.to(this.momentSpring[3], .5 * speed, {
            x: 250,
            y: -250 + 311 + 65 + 75,
            ease: Elastic.easeOut,
            delay: .7 + .3 * speed,
            onComplete: this.onShown2.bind(this)
        })
    } else {
        TweenLite.to(this.topLeft, .5 * speed, {
            x: -250,
            y: -250,
            ease: Back.easeOut,
            delay: delays[0]
        });
        TweenLite.to(this.topRight, .5 * speed, {
            x: 250,
            y: -250,
            ease: Back.easeOut,
            delay: delays[1] * speed
        });
        TweenLite.to(this.bottomRight, .5 * speed, {
            x: 250,
            y: 250,
            ease: Back.easeOut,
            delay: delays[2] * speed,
            onComplete: this.onSquareComplete.bind(this)
        });
        TweenLite.to(this.bottomLeft, .5 * speed, {
            x: -250,
            y: 250,
            ease: Back.easeOut,
            delay: delays[3] * speed,
            onComplete: this.onShown2.bind(this)
        })
    }
    TweenLite.to(this, .5, {
        blackStrength: .75,
        ease: Sine.easeOut
    });
    TweenLite.to(this, .25, {
        imageAlpha: 0,
        ease: Sine.easeOut,
        delay: .2
    })
};
Viewer.prototype.swap = function() {
    var speed = .8;
    TweenLite.to(this.socialSpring[0], .5 * speed, {
        x: 250,
        y: -250 + 311,
        ease: Elastic.easeOut,
        delay: 0
    });
    TweenLite.to(this.socialSpring[1], .5 * speed, {
        x: 250,
        y: -250 + 311,
        ease: Elastic.easeOut,
        delay: .1 * speed
    });
    TweenLite.to(this.socialSpring[2], .5 * speed, {
        x: 250,
        y: -250 + 311,
        ease: Elastic.easeOut,
        delay: .2 * speed
    });
    TweenLite.to(this.socialSpring[3], .5 * speed, {
        x: 250,
        y: -250 + 311,
        ease: Elastic.easeOut,
        delay: .3 * speed
    });
    TweenLite.to(this.momentSpring[0], .5 * speed, {
        x: 250,
        y: -250 + 311 + 65,
        ease: Elastic.easeOut,
        delay: 0
    });
    TweenLite.to(this.momentSpring[1], .5 * speed, {
        x: 250,
        y: -250 + 311 + 65,
        ease: Elastic.easeOut,
        delay: .1 * speed
    });
    TweenLite.to(this.momentSpring[2], .5 * speed, {
        x: 250,
        y: -250 + 311 + 65,
        ease: Elastic.easeOut,
        delay: .2 * speed
    });
    TweenLite.to(this.momentSpring[3], .5 * speed, {
        x: 250,
        y: -250 + 311 + 65,
        ease: Elastic.easeOut,
        delay: .3 * speed,
        onComplete: this.onShown2.bind(this)
    });
    this.color = "#463849"
};
Viewer.prototype.hide = function() {
    var speed = .8;
    TweenLite.to(this.socialSpring[0], .5 * speed, {
        x: 250,
        y: -250 + 311,
        ease: Elastic.easeOut,
        delay: 0
    });
    TweenLite.to(this.socialSpring[1], .5 * speed, {
        x: 250,
        y: -250 + 311,
        ease: Elastic.easeOut,
        delay: .1 * speed
    });
    TweenLite.to(this.socialSpring[2], .5 * speed, {
        x: 250,
        y: -250 + 311,
        ease: Elastic.easeOut,
        delay: .2 * speed
    });
    TweenLite.to(this.socialSpring[3], .5 * speed, {
        x: 250,
        y: -250 + 311,
        ease: Elastic.easeOut,
        delay: .3 * speed
    });
    TweenLite.to(this.momentSpring[0], .5 * speed, {
        x: 250,
        y: -250 + 311 + 65,
        ease: Elastic.easeOut,
        delay: 0
    });
    TweenLite.to(this.momentSpring[1], .5 * speed, {
        x: 250,
        y: -250 + 311 + 65,
        ease: Elastic.easeOut,
        delay: .1 * speed
    });
    TweenLite.to(this.momentSpring[2], .5 * speed, {
        x: 250,
        y: -250 + 311 + 65,
        ease: Elastic.easeOut,
        delay: .2 * speed
    });
    TweenLite.to(this.momentSpring[3], .5 * speed, {
        x: 250,
        y: -250 + 311 + 65,
        ease: Elastic.easeOut,
        delay: .3 * speed
    });
    TweenLite.to(this, .5, {
        blackStrength: 0,
        imageAlpha: 1,
        ease: Sine.easeOut
    });
    TweenLite.to(this.topLeft, .5 * speed, {
        x: -250,
        y: -250,
        ease: Back.easeOut,
        delay: 0
    });
    TweenLite.to(this.topRight, .5 * speed, {
        x: -0,
        y: -250,
        ease: Back.easeOut,
        delay: .1 * speed
    });
    TweenLite.to(this.bottomRight, .5 * speed, {
        x: -0,
        y: -0,
        ease: Back.easeOut,
        delay: .2 * speed
    });
    TweenLite.to(this.bottomLeft, .5 * speed, {
        x: -250,
        y: -0,
        ease: Back.easeOut,
        delay: .3 * speed,
        onComplete: this.onHidden2.bind(this)
    })
};
Viewer.prototype.onSquareComplete = function() {
    if (isIpad) {
        setTimeout(this.onSquareReady.bind(this), 400)
    } else {
        this.onSquareReady()
    }
};
Viewer.prototype.onShown2 = function() {
    this.onShown()
};
Viewer.prototype.onHidden2 = function() {
    this.moment = null;
    this.onHidden()
};






































MomentViewer = function() {
    var soundIds = ["NUwhoosh1", "NUwhoosh2", "NUwhoosh3"];
    this.count = 0;
    this.sounds = [];
    for (var i = 0; i < soundIds.length; i++) {
        this.sounds.push(new Howl({
            urls: [REMOTE_PATH + "sounds/" + soundIds[i] + ".mp3"]
        }))
    }
    this.trail = new Trail;
    this.imagePool = [];
    this.imageCount = 0;
    this.frame = 0;
    this.currentAnimation;
    this.view = document.createElement("div");
    this.view.style.position = "absolute";
    this.view.className = "momentView";
    this.div = document.createElement("div");
    this.div.width = 500;
    this.div.height = 500;
    //this.view.appendChild(this.div);
    this.loaderBar = new Image;
    this.loaderBar.src = REMOTE_PATH + "img/loaderLine.png";
    this.loaderBar.style.position = "absolute";
    this.loaderBar.style.top = "491px";
    this.loaderBar.style.left = "0px";
    this.view.style.width = 500 + "px";
    this.view.style.height = 500 + "px";
    document.body.appendChild(this.view);
    this.gesturepad = new Gesturepad(this.view);
    this.gesturepad.onSwipe = this.onSwipe.bind(this);
    this.gesturepad.onClose = this.closePressed.bind(this);
    this.tempTextTexture = new Image;
    this.closeButton = new Image;
    if (isIpad) {
        this.closeButton.className = "closeButton";
        this.closeButton.src = REMOTE_PATH + "img/closeButton.png"
    } else {
        this.closeButton.className = "closeButtonSmall";
        this.closeButton.src = REMOTE_PATH + "img/closeButtonPetit.png"
    }
    this.detailContainer = document.createElement("div");
    this.detailContainer.className = "detailHeader";
    this.detailDescriptionContainer = document.createElement("div");
    this.detailDescriptionContainer.className = "detailDescription";
    this.detailNameContainer = document.createElement("div");
    this.detailNameContainer.className = "detailName";
    this.view.appendChild(this.detailContainer);
    this.view.appendChild(this.detailDescriptionContainer);
    this.view.appendChild(this.detailNameContainer);
    this.view.appendChild(this.closeButton);
    $(this.closeButton).bind("click", $.proxy(this.closePressed, this));
    $(this.closeButton).bind("touchstart", $.proxy(this.closePressed, this));
    this.isOpen = false
};
MomentViewer.constructor = MomentViewer;
MomentViewer.prototype.tellPressed = function(event) {
    event.preventDefault();
    if (!this.isOpen) return;
    this.buttonTouch = true;
    SOUNDS.clickOpen.play();
    this.isOpen = false;
    if (this.onSwapPressed) this.onSwapPressed();
    $(this.view).fadeOut();
    this.gesturepad.disable();
    this.moment = null
};
MomentViewer.prototype.closePressed = function(event) {
    if (event) event.preventDefault();
    if (!this.isOpen) return;
    if (this.buttonTouch) {
        this.buttonTouch = false;
        return
    }
    SOUNDS.clickClose.play();
    this.isOpen = false;
    if (this.onClosePressed) this.onClosePressed();
    $(this.view).fadeOut();
    this.gesturepad.disable();
    this.moment = null
};
MomentViewer.prototype.sharePressed = function() {
    this.buttonTouch = true;
    FacebookAPI.postToFeed(this.moment);
    SOUNDS.clickOpen.play()
};
MomentViewer.prototype.buildAnimation = function() {
    if (!this.isOpen) return;
    this.gesturepad.enable();
    //this.currentAnimation = this.animationData.idle_animation;
    this.frame = 0;
    $(this.loaderBar).fadeOut(300);
    TweenLite.to(this, .5, {
        alpha: 1,
        ease: Sine.easeIn
    })
};
MomentViewer.prototype.update = function() {

};
MomentViewer.prototype.show = function(moment) {
    this.isOpen = true;
    this.detailContainer.innerHTML = moment.copy;
    this.detailDescriptionContainer.innerHTML = moment.story;
    this.detailNameContainer.innerHTML = "<b><a href='http://"+moment.url+"' target='_blank'>" + moment.url + "</a></b>";
    this.detailContainer.style.color = this.detailDescriptionContainer.style.color = moment.textColor1 || "#FFFFFF";
    this.detailNameContainer.style.color = moment.textColor2 || "#FFFFFF";
    this.hasLoaded = false;
    this.moment = moment;
    this.imageCount = 0;
    this.alpha = 0;
    $(this.loaderBar).fadeIn(.1);
    //var path = moment.id + "/animationData.json";
    $.ajax({
        type: "GET",
        //url: REMOTE_PATH + "moments/" + moment.id + "/animationData.json",
        async: false,
        contentType: "application/json",
        dataType: "json",
        success: this.onJSONLoaded.bind(this)
    });
    $(this.view).fadeIn()
};
MomentViewer.prototype.onJSONLoaded = function(data) {
    if (!this.isOpen) return;
    //this.animationData = data.data;
   // var totalImages = this.animationData.total_images;
    var imageFolder = REMOTE_PATH + "moments/" + this.moment.id + "/";
    //var imagePrefix = this.animationData.images_prefix;
    imagePrefix = imagePrefix.split("XX")[0];
    for (var i = 0; i < totalImages; i++) {
        if (!this.imagePool[i]) {
            this.imagePool[i] = new Image
        }
        this.imagePool[i].onload = this.onImageLoaded.bind(this);
        var coutPrefix = i + 1;
        if (coutPrefix < 10) coutPrefix = "0" + coutPrefix;
        this.imagePool[i].src = imageFolder + imagePrefix + coutPrefix + ".png";
        if (this.imagePool[i].complete) this.imageCount++
    }
    if (this.animationData.total_images == this.imageCount) {
        this.hasLoaded = true;
        this.buildAnimation()
    }
};
MomentViewer.prototype.onImageLoaded = function() {
    if (!this.moment) return;
    this.imageCount++;
};
MomentViewer.prototype.collectSound = function(soundID) {
    if (!this.animationData[soundID]) {
        this.animationData[soundID] = new Howl({
            urls: [REMOTE_PATH + "sounds/" + soundID + ".mp3", "sounds/" + soundID + ".ogg"]
        })
    }
};
MomentViewer.prototype.onSwipe = function(direction) {
    var soundID;
    if (soundID) {
        this.animationData[soundID].play()
    } else {
        this.sounds[this.count % this.sounds.length].play();
        this.count++
    }
};
MomentViewer.prototype.playAnimation = function(animation) {
    if (!animation) animation = this.animationData.idle_animation;
    this.currentAnimation = animation;
    this.frame = 0
};









Date.now = Date.now || function() {
    return +new Date
};
Time = function() {
    this.DELTA_TIME = 1;
    this.lastTime = Date.now();
    this.frames = 0;
    this.speed = 1
};
Time.constructor = Time;
Time.prototype.update = function() {
    this.frames++;
    var time = Date.now();
    this.frames = 0;
    var currentTime = time;
    var passedTime = currentTime - this.lastTime;
    this.DELTA_TIME = passedTime * .06;
    this.DELTA_TIME *= this.speed;
    if (this.DELTA_TIME > 2.3) this.DELTA_TIME = 2.3;
    this.lastTime = currentTime
};
AssetLoader = function() {
    this.images = [];
    this.total = 0;
    this.position = 0;
    this.onLoadComplete;
    this.onProgress
};
AssetLoader.constructor = AssetLoader;
AssetLoader.prototype.addImages = function(images) {
    for (var i = 0; i < images.length; i++) {
        var imageToLoad = new Image;
        imageToLoad.srcToLoad = images[i];
        this.images.push(imageToLoad)
    }
    this.total = this.images.length
};
AssetLoader.prototype.load = function() {
    console.log("LOAD START");
    this.position = 0;
    this.loadNext()
};
AssetLoader.prototype.loadNext = function() {
    var imageToLoad = this.images[this.position];
    imageToLoad.onload = $.proxy(this.onImageLoaded, this);
    imageToLoad.onerror = $.proxy(this.onImageError, this);
    imageToLoad.src = imageToLoad.srcToLoad
};
AssetLoader.prototype.onImageError = function() {
    alert(this.images[this.position].src)
};
AssetLoader.prototype.onImageLoaded = function() {
    this.onProgress();
    var imageToLoad = this.images[this.position];
    imageToLoad.onLoad = null;
    if (this.position == this.images.length - 1) {
        if (this.onLoadComplete) this.onLoadComplete()
    } else {
        this.position++;
        this.loadNext()
    }
};






GridButton = function(framesIds) {
    this.framesIds = framesIds;
    this.frames = [];
    this.view = document.createElement("div");
    this.view.style.position = "absolute";
    for (var i = 0; i < framesIds.length; i++) {
        var image = new Image;
        image.src = REMOTE_PATH + framesIds[i];
        this.frames.push(image)
    }
    this.currentframe = 0;
    this.speed = .2;
    this.time = new Time
};
GridButton.constructor = GridButton;
GridButton.prototype.play = function() {};
GridButton.prototype.getNextImage = function() {
    this.time.update();
    this.currentframe += this.time.DELTA_TIME * this.speed * 2;
    var actualFrame = Math.floor(this.currentframe);
    return this.frames[actualFrame % this.frames.length]
};
var Trail = function() {
    function Trail() {
        this.totalPoints = 15;
        this.colors = ["#ebffff", "#fee5fa", "#effee5", "#fef9e5"];
        this.currentColor = 0;
        this.count = 0;
        this.points = [];
        this.pointsPerp = [];
        for (var i = 0; i < this.totalPoints; i++) {
            this.points.push(0, 0);
            this.pointsPerp.push(0, 0)
        }
    }
    Trail.prototype.update = function(context, mouseX, mouseY) {
        this.count++;
        this.count %= this.totalPoints;
        this.points[this.count * 2] = mouseX;
        this.points[this.count * 2 + 1] = mouseY;
        this.setPerpendiculer();
        for (var i = 0; i < this.totalPoints; i += 1) {}
        context.lineWidth = 3;
        context.fillStyle = this.colors[this.currentColor];
        context.beginPath();
        for (var i = 1; i < this.totalPoints; i++) {
            var modi = (i + this.count) % this.totalPoints;
            var width = i * .8;
            context.lineTo(this.points[modi * 2] - this.pointsPerp[modi * 2] * width, this.points[modi * 2 + 1] - this.pointsPerp[modi * 2 + 1] * width)
        }
        context.lineTo(this.points[this.count * 2], this.points[this.count * 2 + 1]);
        for (var i = 0; i < this.totalPoints; i++) {
            var modi = this.totalPoints - i;
            var width = modi * .8;
            modi = (modi + this.count) % this.totalPoints;
            context.lineTo(this.points[modi * 2] + this.pointsPerp[modi * 2] * width, this.points[modi * 2 + 1] + this.pointsPerp[modi * 2 + 1] * width)
        }
        context.globalAlpha = .7;
        context.fill()
    };
    Trail.prototype.setPerpendiculer = function() {
        var p0i = (this.count - 1) % this.totalPoints;
        var p0x = this.points[p0i * 2];
        var p0y = this.points[p0i * 2 + 1];
        var p1i = this.count % this.totalPoints;
        var p1x = this.points[p1i * 2];
        var p1y = this.points[p1i * 2 + 1];
        var p2i = this.count % this.totalPoints;
        var p2x = this.points[p2i * 2];
        var p2y = this.points[p2i * 2 + 1];
        var perpy = -(p0x - p2x);
        var perpx = p0y - p2y;
        var perpLength = Math.sqrt(perpx * perpx + perpy * perpy);
        perpx /= perpLength;
        perpy /= perpLength;
        if (perpLength < 2) {
            perpx = 0;
            perpy = 0
        }
        this.pointsPerp[this.count * 2] = perpx;
        this.pointsPerp[this.count * 2 + 1] = perpy
    };
    Trail.prototype.reset = function(mouseX, mouseY) {
        for (var i = 0; i < this.totalPoints; i++) {
            this.points[i * 2] = mouseX;
            this.points[i * 2 + 1] = mouseY;
            this.pointsPerp[i * 2] = 0;
            this.pointsPerp[i * 2 + 1] = 0
        }
        this.currentColor++;
        this.currentColor %= this.colors.length
    };
    return Trail
}();











$.support.cors = true;
$(window).ready(onReady);
window.mobilecheck = function() {
    var check = false;
    ! function(a) {
        if (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows (ce|phone)|xda|xiino/i.test(a) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0, 4))) check = true
    }(navigator.userAgent || navigator.vendor || window.opera);
    return check
};
isIpad = navigator.userAgent.match(/iPad/i) != null;
isMobile = window.mobilecheck();
var soundButton;
var SOUNDS = {};

function onReady() {
    IS_IE8 = false; // !Modernizr.canvas
    $("head").append('<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">');
    siteTime = new Time;
    last = 0;
    loaded = false;
    resizeCount = 0;
    if (!IS_IE8) {
        SOUNDS.clickOpen = new Howl({
            urls: [REMOTE_PATH + "sounds/clickOpen.mp3", REMOTE_PATH + "sounds/clickOpen.ogg"]
        });
        SOUNDS.clickClose = new Howl({
            urls: [REMOTE_PATH + "sounds/clickClose.mp3", REMOTE_PATH + "sounds/clickClose.ogg"]
        });
        SOUNDS.rollOver = new Howl({
            urls: [REMOTE_PATH + "sounds/rollover.mp3", REMOTE_PATH + "sounds/rollover.ogg"],
            volume: .5
        });
        SOUNDS.drag = new Howl({
            urls: [REMOTE_PATH + "sounds/dragGrid.mp3", REMOTE_PATH + "sounds/dragGrid.ogg"],
            loop: true
        })
    }
    soundButton = document.getElementById("soundButton");
    soundButton.image = document.getElementById("soundButtonImage");
    soundButton.label = document.getElementById("soundButtonLabel");
    soundButton.image.src = REMOTE_PATH + "img/sound_ON.png";
    soundButton.label.innerHTML = "<b>Sound On</b>";
    var MUTE = false;
    $(soundButton).bind("click", soundToggle);
    $(soundButton).bind("touchstart", soundToggle);
    if (!model.dimensions) model.dimensions = [5, 5];
    init()
}

function soundToggle(e) {
    if (e) {
        e.preventDefault()
    }
    soundButton.toggle = !soundButton.toggle;
    if (!soundButton.toggle) {
        soundButton.image.src = REMOTE_PATH + "img/sound_ON.png";
        soundButton.label.innerHTML = "<b>Sound On</b>";
        MUTE = false;
        Howler.unmute()
    } else {
        soundButton.image.src = REMOTE_PATH + "img/sound_OFF.png";
        soundButton.label.innerHTML = "<b>Sound Off</b>";
        MUTE = true;
        Howler.mute()
    }
}

var xdr;

function err() {
    alert("Error")
}

function timeo() {
    alert("Time off")
}

function loadd() {
    alert("Response: " + xdr.responseText)
}

function stopdata() {
    xdr.abort()
}

function load() {
    loaderScreen = new LoaderScreen;
    loaderScreen.onComplete = init;
    document.body.appendChild(loaderScreen.view);
    onResize();
    if (isIpad) {} else {}
    $(window).resize(onResize)
}

function init() {
    onResize();
    $(window).resize(onResize);
    loaded = true;
    var windowWidth = window.innerWidth || document.documentElement.clientWidth;
    var windowHeight = window.innerHeight || document.documentElement.clientHeight;
	
    canvas = document.createElement("canvas");
    canvas.width = windowWidth;
    canvas.height = windowHeight;
    context = canvas.getContext("2d");
    canvas.style.position = "absolute";
    canvas.style.top = "0px";
    canvas.style.left = "0px";
    document.body.appendChild(canvas);
    canvas.style.display = "none";
    $(canvas).fadeIn("slow");
    $(canvas).mousedown(onMouseDown);
    $(canvas).mouseup(onMouseUp);
    $(canvas).mousemove(onMouseMove);
    $(canvas).bind("touchstart", onTouchStart);
    $(canvas).bind("touchend", onTouchEnd);
    $(canvas).bind("touchmove", onTouchMove);
    grid = new Grid(windowWidth, windowHeight);
    grid.onMomentSelected = onMomentSelected;
    
    trackpad = new Trackpad(canvas);
    
    viewer = new Viewer(windowWidth, windowHeight);
    viewer.onShown = onViewerShown;
    viewer.onSquareReady = onSquareReady;
    viewer.onHidden = onViewerHidden;

    momentViewer = new MomentViewer
    momentViewer.onClosePressed = hideMoment;
    momentViewer.onSwapPressed = onSwapPressed;
    browseMode = false;
    pauseGridRender = false;
    
    onResize();
    resizeCount = 19;
    trackpad.lock();
    var start = model.layout.indexOf(0);
    var layoutWidth = model.dimensions[0];
    var startX = -2;
    var startY = -2;
    trackpad.setPosition(windowWidth / 2 + startX * 250 + 250 / 2, windowHeight / 2 + startY * 250);
    grid.onStartComplete = onGridStartComplete;
    grid.startIntro();
    requestAnimFrame(update)
}

function onGridStartComplete() {
    var hashString = window.location.hash;
    var id = hashString.split("=")[1];
    var moment;
    if (id) {
        for (var i = 0; i < model.content.length; i++) {
            if (id == model.content[i].rfid) {
                moment = model.content[i];
                break
            }
        }
    }
    if (moment) {
        var pX = 2;
        var pY = 2;
        moment.positionX = (pX + 2 - .5) * grid.squareWidth + grid.width / 2 - grid.squareWidth / 2 + 1;
        moment.positionY = (pY + 1.5 - .5) * grid.squareWidth + grid.height / 2 - grid.squareWidth / 2 + 1;
        showMoment(moment)
    } else {
        browseMode = true;
        trackpad.unlock()
    }
}

function update() {
    resizeCount++;
    if (resizeCount == 20) {
        var w = $(window).width();
        var h = $(window).height();
        if (!IS_IE8) {
            canvas.width = w;
            canvas.height = h
        }
        grid.resize(w, h);
        viewer.resize(w, h);
        
        momentViewer.view.style.left = w / 2 + -250 + "px";
        momentViewer.view.style.top = h / 2 - 250 + "px";
        if (pauseGridRender) {
            if (!IS_IE8) {
                grid.render(context);
                viewer.render(context)
            } else {
                grid.render()
            }
        }
        if (w != this.cacheW && h != this.cacheH) {
            window.scrollTo(0, 0)
        }
        this.cacheW = w;
        this.cacheH = h
    }
    siteTime.update();
    if (loaded && browseMode) {
        trackpad.update()
    }
    track.x = trackpad.value;
    track.y = trackpad.valueY;
    if (!pauseGridRender) {
        if (!IS_IE8) {
            grid.render(context);
            viewer.render(context)
        } else {
            grid.render()
        }
    } else {}
    momentViewer.update();
    requestAnimFrame(update)
}

function showMoment(moment) {
    if (!IS_IE8) SOUNDS.clickOpen.play();
    if (IS_IE8) {
        if (moment.id == "share") {
            openForm();
            return
        }
    }
    this.moment = moment;
    browseMode = false;
    viewer.showMoment(moment);
    trackpad.lock();
    TweenLite.to(trackpad, .5, {
        value: moment.positionX,
        easingValue: moment.positionX,
        valueY: moment.positionY,
        easingValueY: moment.positionY,
        ease: Sine.easeOut
    });
    grid.centerOnMoment();
    if (moment.id != "share" && moment.id != "startx") {
        window.location.hash = "momentid=" + moment.rfid
    } else {
        window.location.hash = ""
    }
}

function onSwapPressed() {
    window.location.hash = "";
    pauseGridRender = false;
    viewer.swap();
   // submitForm.show()
}

function hideMoment() {
    pauseGridRender = false;
    viewer.hide();
    window.location.hash = "";
    if (moment.id == "share") {
        //submitForm.hide()
    }
}

function onViewerShown() {
    if (momentViewer.isOpen) pauseGridRender = true;
    if (!IS_IE8) {
        grid.render(context);
        viewer.render(context)
    }
}

function onSquareReady() {
    if (moment.id == "share") {
       // submitForm.show()
    } else if (moment.id == "startx") {
        //submitForm.show({})
    } else {
        momentViewer.show(moment)
    }
}

function onViewerHidden() {
    trackpad.unlock();
    grid.unlock();
    browseMode = true
}

function onMomentSelected(moment) {
    showMoment(moment)
}

function onSubmitComplete() {
   // submitForm.hide();
    trackpad.unlock();
    grid.unlock();
    browseMode = true
}

function onResize() {
    resizeCount = 0;
    //if (loaderScreen) {
    //    loaderScreen.resize(window.innerWidth || document.documentElement.clientWidth, window.innerHeight || document.documentElement.clientHeight)
  //  }
}
mouse = {
    x: 0,
    y: 0
};
track = {
    x: 0,
    y: 0
};
downTarget = {
    x: 0,
    y: 0
};

function onMouseDown(event) {
    event.preventDefault();
    downTarget.x = mouse.x;
    downTarget.y = mouse.y;
    if (!browseMode) return;
    grid.down()
}

function onMouseUp(event) {
    event.preventDefault();
    if (pauseGridRender) {}
    if (!browseMode) return;
    grid.up()
}

function onTouchStart(event) {
    event.preventDefault();
    mouse.x = event.pageX + document.body.scrollLeft;
    mouse.y = event.pageY + document.body.scrollTop;
    downTarget.x = mouse.x;
    downTarget.y = mouse.y;
    if (!browseMode) return;
    if (!grid.firstTouch) {
        grid.firstTouch = true;
        SOUNDS.drag.play()
    }
    grid.down()
}

function onTouchEnd(event) {
    event.preventDefault();
    if (pauseGridRender) {}
    if (!browseMode) return;
    grid.up()
}

function onTouchMove(event) {
    event.preventDefault();
    mouse.x = event.pageX + document.body.scrollLeft;
    mouse.y = event.pageY + document.body.scrollTop;
    testDidMove()
}

function onMouseMove(event) {
    mouse.x = event.clientX + document.body.scrollLeft;
    mouse.y = event.clientY + document.body.scrollTop;
    testDidMove()
}

function testDidMove() {
    var xdist = mouse.x - downTarget.x;
    var ydist = mouse.y - downTarget.y;
    var dist = xdist * xdist + ydist * ydist;
    if (dist > 30 * 30) {
        grid.didMove = true
    }
}